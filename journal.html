<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="description" content="Calculated Camouflage - Viewer Journal">
  <meta name="theme-color" content="#000000">
  <title>Viewer Journal | Calculated Camouflage</title>
  
  <!-- Preload critical resources -->
  <link rel="preload" href="fonts/403-super-vega-regular.woff" as="font" type="font/woff" crossorigin>
  
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Alegreya:ital@1&family=JetBrains+Mono:wght@500&family=Nanum+Myeongjo:wght@700&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
  <noscript><link href="https://fonts.googleapis.com/css2?family=Alegreya:ital@1&family=JetBrains+Mono:wght@500&family=Nanum+Myeongjo:wght@700&display=swap" rel="stylesheet"></noscript>
  
  <style>
    /* ============================================
       403 Super Vega Custom Font
       ============================================ */
    @font-face {
      font-family: '403 Super Vega';
      src: url('fonts/403-super-vega-regular.woff') format('woff');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    /* ============================================
       CSS Custom Properties
       ============================================ */
    :root {
      --color-bg: #000000;
      --color-text: #FFFFFF;
      --color-acrylic-yellow: #FDFF00;
      
      --font-title: '403 Super Vega', sans-serif;
      --font-body: 'Nanum Myeongjo', serif;
      --font-mono: 'JetBrains Mono', monospace;
      --font-arrow: 'Alegreya', serif;
      
      --title-size: 136px;
      --title-line-height: 130px;
      --title-letter-spacing: -4px;
      
      --body-size: 20px;
      --body-line-height: 26px;
      
      --label-size: 14px;
      --label-line-height: 14px;
      
      --arrow-size: 18px;
      --arrow-line-height: 21.6px;
      
      --page-padding: 30px;
      --corner-size: 25px;
      --content-max-width: 375px;
    }

    /* ============================================
       Reset & Base Styles
       ============================================ */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      overflow: hidden;
      background-color: var(--color-bg);
    }
    
    main {
      overflow: visible !important;
    }

    body {
      color: var(--color-text);
      font-family: var(--font-body);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      position: relative;
    }

    /* Noise overlay */
    body::after {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      opacity: 0.04;
      pointer-events: none;
      z-index: 1000;
    }

    /* ============================================
       Corner Accents
       ============================================ */
    .corner-accent {
      position: fixed;
      width: var(--corner-size);
      height: var(--corner-size);
      background-color: var(--color-text);
      z-index: 100;
      pointer-events: none;
    }

    .corner-accent.top-left { top: 0; left: 0; }
    .corner-accent.top-right { top: 0; right: 0; }
    .corner-accent.bottom-left { bottom: 0; left: 0; }
    .corner-accent.bottom-right { bottom: 0; right: 0; }

    /* ============================================
       Back Button
       ============================================ */
    .back-button {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 8px 14px;
      background: transparent;
      border: 1px solid var(--color-text);
      border-radius: 30px;
      color: var(--color-text);
      text-decoration: none;
      font-family: var(--font-mono);
      font-size: var(--label-size);
      font-weight: 500;
      text-transform: uppercase;
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      transition: all 0.2s ease;
      width: fit-content;
      margin-bottom: 20px;
    }

    .back-button:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.4);
    }

    .back-arrow {
      font-family: var(--font-arrow);
      font-size: 16px;
      font-style: italic;
    }

    /* ============================================
       Journal Page Layout
       ============================================ */
    .journal-page {
      display: flex;
      height: 100vh;
      width: 100vw;
      position: relative;
    }

    /* ============================================
       Left Content Section
       ============================================ */
    .journal-content {
      display: flex;
      flex-direction: column;
      padding: var(--page-padding);
      padding-top: 35px;
      width: 40%;
      min-width: 480px;
      max-width: 540px;
      position: relative;
      z-index: 10;
      height: 100vh;
    }

    .journal-title {
      font-family: var(--font-title);
      font-size: var(--title-size);
      font-weight: normal;
      line-height: var(--title-line-height);
      letter-spacing: var(--title-letter-spacing);
      white-space: nowrap;
      margin-bottom: 0;
    }

    .journal-description {
      font-family: var(--font-body);
      font-size: var(--body-size);
      font-weight: 700;
      line-height: var(--body-line-height);
      max-width: var(--content-max-width);
      margin-top: auto;
      margin-bottom: 40px;
    }

    .journal-info {
      max-width: var(--content-max-width);
    }

    .learn-more {
      font-family: var(--font-body);
      font-size: var(--body-size);
      font-weight: 700;
      line-height: var(--body-line-height);
      margin-bottom: 22px;
    }

    /* Navigation Buttons */
    .nav-links {
      display: flex;
      gap: 10px;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 8px 14px;
      border-radius: 30px;
      text-decoration: none;
      white-space: nowrap;
      transition: all 0.2s ease;
      width: fit-content;
    }

    .btn:hover {
      opacity: 0.8;
      transform: translateY(-1px);
    }

    .btn-text {
      font-family: var(--font-mono);
      font-size: var(--label-size);
      font-weight: 500;
      line-height: var(--label-line-height);
      text-transform: uppercase;
    }

    .btn-arrow {
      font-family: var(--font-arrow);
      font-size: var(--arrow-size);
      font-style: italic;
      line-height: 1;
      margin-right: -2px;
      flex-shrink: 0;
    }

    .btn-primary {
      background-color: var(--color-text);
      color: var(--color-bg);
    }

    .btn-secondary {
      background-color: transparent;
      color: var(--color-text);
      border: 1px solid var(--color-text);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }

    .btn-secondary.active {
      background-color: rgba(255, 255, 255, 0.1);
    }

    /* CTA Styles */
    .cta-text {
      font-family: var(--font-body);
      font-size: var(--body-size);
      font-weight: 700;
      line-height: var(--body-line-height);
      margin-bottom: 22px;
      white-space: nowrap;
    }

    .cta-primary-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 22px;
      flex-wrap: nowrap;
    }

    .cta-primary-row .cta-text {
      margin-bottom: 0;
      display: inline;
      white-space: nowrap;
    }

    .cta-arrow {
      font-family: var(--font-body);
      font-size: var(--body-size);
      font-weight: 700;
      color: var(--color-text);
      line-height: var(--body-line-height);
    }

    /* ============================================
       3D Book Section (Right Side)
       ============================================ */
    .book-section {
      flex: 1;
      position: relative;
      height: 100vh;
      min-width: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: visible;
      z-index: 1;
    }

    #book-container {
      width: 200%;
      height: 150%;
      position: absolute;
      top: -25%;
      left: -50%;
      cursor: pointer;
      overflow: visible;
      pointer-events: auto;
    }
    
    #book-container canvas {
      overflow: visible !important;
    }

    /* ============================================
       Page Controls (D-pad style)
       ============================================ */
    .page-controls {
      position: absolute;
      bottom: 68px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
    }

    .page-dpad {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .arrow-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.15);
      border: 1.5px solid rgba(255, 255, 255, 0.5);
      color: rgba(255, 255, 255, 0.9);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      transition: all 0.15s ease;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .arrow-btn:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.7);
    }

    .arrow-btn:active,
    .arrow-btn.pressed {
      background: rgba(255, 255, 255, 0.35);
      border-color: rgba(255, 255, 255, 0.8);
      color: #fff;
      transform: scale(0.92);
    }

    .arrow-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .arrow-btn:disabled:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.5);
      transform: none;
    }

    .arrow-btn svg {
      width: 20px;
      height: 20px;
    }

    .page-indicator {
      font-family: var(--font-mono);
      font-size: 13px;
      color: rgba(255, 255, 255, 0.7);
      min-width: 50px;
      text-align: center;
      letter-spacing: 1px;
    }

    /* Loading state */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--color-bg);
      z-index: 50;
      transition: opacity 0.5s ease;
    }

    .loading-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-top-color: var(--color-acrylic-yellow);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Desktop/Mobile visibility */
    .desktop-only { display: block; }
    .mobile-only { display: none !important; }
    .journal-footer-mobile { display: none; }
    .journal-footer-mobile .nav-links { display: none; }

    /* ============================================
       Instruction Footer (matches installation page)
       ============================================ */
    .journal-footer {
      pointer-events: auto;
      width: 100%;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: absolute;
      bottom: 32px;
      left: 0;
      right: 0;
      z-index: 90;
    }

    .instruction-text {
      font-family: var(--font-body);
      font-size: var(--body-size);
      font-weight: 700;
      line-height: var(--body-line-height);
      margin-bottom: 0;
      opacity: 0.8;
      white-space: nowrap;
    }

    /* ============================================
       Responsive - Tablet (1024px and below)
       ============================================ */
    @media screen and (max-width: 1024px) {
      :root {
        --title-size: 90px;
        --title-line-height: 86px;
        --title-letter-spacing: -3px;
      }
    }

    /* ============================================
       Mobile Responsive Styles
       ============================================ */
    @media screen and (max-width: 768px) {
      :root {
        --title-size: 42px;
        --title-line-height: 40px;
        --title-letter-spacing: -1px;
        --body-size: 15px;
        --body-line-height: 24px;
        --page-padding: 20px;
        --corner-size: 15px;
      }
      
      /* Show/hide based on device */
      .mobile-only {
        display: block !important;
      }
      
      .desktop-only {
        display: none !important;
      }
      
      .journal-page {
        flex-direction: column;
        height: 100vh;
        height: 100dvh;
        overflow: hidden;
      }
      
      .journal-content {
        width: 100%;
        min-width: 0;
        max-width: none;
        padding: 25px var(--page-padding) 0;
        height: auto;
        flex-shrink: 0;
        order: 1;
      }
      
      .journal-title {
        margin-bottom: 0 !important;
      }
      
      .journal-content .journal-info,
      .journal-content .journal-description {
        display: none !important;
      }
      
      .journal-footer-mobile {
        display: none !important;
      }
      
      .journal-footer-mobile .cta-text {
        display: none;
      }
      
      .journal-footer-mobile .cta-primary-row {
        display: none;
      }
      
      .journal-footer-mobile .nav-links {
        display: none !important;
      }
      
      .journal-description.mobile-only {
        display: block !important;
        font-family: var(--font-body);
        font-size: 15px;
        font-weight: 700;
        line-height: 24px;
        max-width: 315px;
        margin: 0;
        margin-top: 8px;
        padding: 0 var(--page-padding);
        flex-shrink: 0;
        order: 2;
      }
      
      .book-section {
        flex: 1;
        min-height: 300px;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        order: 3;
        position: relative;
        padding-bottom: 100px; /* Space for controls + footer */
      }
      
      #book-container {
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
        position: relative;
      }
      
      /* Page controls mobile adjustments */
      .page-controls {
        position: fixed;
        bottom: 55px;
        left: 50%;
        transform: translateX(-50%);
      }
      
      .page-dpad {
        gap: 10px;
      }
      
      .arrow-btn {
        width: 40px;
        height: 40px;
      }
      
      .arrow-btn svg {
        width: 18px;
        height: 18px;
      }
      
      .page-indicator {
        font-size: 11px;
        min-width: 40px;
      }
      
      /* Journal footer mobile adjustments (matches installation page) */
      .journal-footer {
        display: flex !important;
        position: fixed !important;
        bottom: 16px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        width: auto !important;
        padding: 0 !important;
        z-index: 90;
      }
      
      .instruction-text {
        font-family: var(--font-body);
        font-size: var(--body-size);
        font-weight: 700;
        line-height: var(--body-line-height);
        text-align: center;
        opacity: 0.6;
      }
      
      .back-button {
        padding: 6px 12px;
        font-size: 12px;
        margin-bottom: 10px;
      }
      
      .back-arrow { font-size: 14px; }
    }

    @media screen and (max-width: 480px) {
      :root {
        --title-size: 48px;
        --title-line-height: 44px;
        --title-letter-spacing: -1.5px;
      }
      
      .nav-links {
        gap: 5px;
      }
      
      .btn {
        padding: 5px 10px;
      }
      
      .btn-text {
        font-size: 10px;
      }
      
      .btn-arrow {
        font-size: 12px;
      }
      
      .arrow-btn {
        width: 36px;
        height: 36px;
      }
      
      .arrow-btn svg {
        width: 16px;
        height: 16px;
      }
    }

    /* Page transition overlay */
    .page-transition-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000;
      z-index: 9999;
      opacity: 1;
      transition: opacity 0.3s ease-out;
      pointer-events: none;
    }
    .page-transition-overlay.hidden {
      opacity: 0;
    }
  </style>
</head>
<body>
  <!-- Page Transition Overlay -->
  <div class="page-transition-overlay"></div>
  
  <!-- Corner Accents -->
  <div class="corner-accent top-left"></div>
  <div class="corner-accent top-right"></div>
  <div class="corner-accent bottom-left"></div>
  <div class="corner-accent bottom-right"></div>

  <!-- Main Content Container -->
  <main class="journal-page">
    <!-- Left Content Section -->
    <section class="journal-content">
      <!-- Back Button -->
      <a href="index.html" class="back-button">
        <span class="back-arrow">←</span>
        <span class="back-text">BACK</span>
      </a>
      <h1 class="journal-title">VIEWER<br>JOURNAL</h1>
      
      <p class="journal-description desktop-only">
        While the installation ran, a journal sat open, inviting visitors to leave their mark.
      </p>
      
      <div class="journal-info">
        <div class="cta-primary-row">
          <span class="cta-arrow">↳</span>
          <span class="cta-text">See it for yourself</span>
          <a href="installation.html" class="btn btn-primary">
            <span class="btn-text">VIEW ROOM</span>
            <span class="btn-arrow">→</span>
          </a>
        </div>
        
        <nav class="nav-links">
          <a href="what-is-this.html" class="btn btn-secondary">
            <span class="btn-text">what is this</span>
            <span class="btn-arrow">→</span>
          </a>
          <a href="journal.html" class="btn btn-secondary">
            <span class="btn-text">viewer journal</span>
            <span class="btn-arrow">→</span>
          </a>
          <a href="gallery.html" class="btn btn-secondary">
            <span class="btn-text">gallery</span>
            <span class="btn-arrow">→</span>
          </a>
        </nav>
      </div>
    </section>

    <!-- 3D Book Section -->
    <section class="book-section">
      <div class="loading-overlay" id="loading">
        <div class="loading-spinner"></div>
      </div>
      
      <div id="book-container"></div>
      
      <!-- Page Controls (D-pad style) -->
      <div class="page-controls" id="page-controls">
        <div class="page-dpad">
          <button class="arrow-btn arrow-left" id="btn-prev" aria-label="Previous page">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M19 12H5M12 5l-7 7 7 7"/>
            </svg>
          </button>
          <span class="page-indicator"><span id="current-page">1</span> / <span id="total-pages">12</span></span>
          <button class="arrow-btn arrow-right" id="btn-next" aria-label="Next page">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M5 12h14M12 5l7 7-7 7"/>
            </svg>
          </button>
        </div>
      </div>

      <!-- Instruction Footer -->
      <footer class="journal-footer">
        <p class="instruction-text">Swipe to rotate. Tap pages to flip.</p>
      </footer>
    </section>
    
    <!-- Mobile Description -->
    <p class="journal-description mobile-only">
      While the installation ran, a journal sat open, inviting visitors to leave their mark.
    </p>
    
    <!-- Mobile Footer (hidden on mobile) -->
    <footer class="journal-footer-mobile"></footer>
  </main>

  <!-- Load three.modifiers UMD bundle first -->
  <script src="vendor/quick_flipbook/modifiers.min.js"></script>
  
  <!-- Import map for ES modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/": "https://cdn.jsdelivr.net/npm/three@0.160.0/",
      "three/examples/jsm/utils/BufferGeometryUtils.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/utils/BufferGeometryUtils.js",
      "three.modifiers": "https://cdn.jsdelivr.net/npm/three.modifiers@2.5.7/dist/modifiers.min.js"
    }
  }
  </script>

  <!-- Debug instrumentation -->
  <script>
    // #region agent log
    window.addEventListener('DOMContentLoaded', function() {
      const btn = document.querySelector('.btn');
      if (btn) {
        const cs = getComputedStyle(btn);
        const text = btn.querySelector('.btn-text');
        const arrow = btn.querySelector('.btn-arrow');
        const textCs = text ? getComputedStyle(text) : null;
        const arrowCs = arrow ? getComputedStyle(arrow) : null;
        fetch('http://127.0.0.1:7243/ingest/b2a87bc5-0f45-4c1a-95fa-5aa2d366c868',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'journal.html',message:'CTA computed styles',data:{page:'journal',viewportWidth:window.innerWidth,viewportHeight:window.innerHeight,btnPadding:cs.padding,btnGap:cs.gap,textFontSize:textCs?.fontSize,arrowFontSize:arrowCs?.fontSize},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'A,B,C'})}).catch(()=>{});
      }
    });
    // #endregion
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { mergeGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js';
    
    // Use the global three.modifiers from UMD bundle
    const MODIFIERS = window;

    // ============================================
    // Page images configuration
    // ============================================
    const pageImages = [
        'assets/R0002034.jpg',
      'assets/R0002068_2.jpg',
      'assets/R0002097_1.jpg',
      'assets/R0002355_1.jpg',
      'assets/R0002358_1.jpg',
      'assets/DSC_4949_1.jpg',
      'assets/IMG_4179_2.jpg',
      'assets/IMG_4216_1.jpg',
      'assets/IMG_4223_1.jpg',
      'assets/IMG_4227_2.jpg',
      'assets/Frame_11.jpg'
    ];

    // ============================================
    // PageCurve Modifier (custom modifier for book page curl)
    // ============================================
    class PageCurve extends MODIFIERS.UserDefined {
      constructor(elevationAxis = MODIFIERS.ModConstant.Y, alongAxis = MODIFIERS.ModConstant.X, effectRange = 0.5, effectMid = 0.5, elevationHeight = 0.5) {
        super();
        this.elevationAxis = elevationAxis;
        this.alongAxis = alongAxis;
        this.effectRange = effectRange;
        this.effectMid = effectMid;
        this.elevationHeight = elevationHeight;
        this.intensity = 1;
        this.renderVector = this._renderVector;
      }

      _renderVector(vec, i, l) {
        let radio = vec.getRatio(this.alongAxis);
        let val = vec.getValue(this.elevationAxis);

        if (radio <= this.effectRange) {
          radio /= this.effectRange;
          let elevation = 0;

          if (radio < this.effectMid) {
            radio = radio / this.effectMid;
            elevation = Math.sqrt(1 - Math.pow(radio, 2) + radio * 2 - 1);
          } else {
            radio = (radio - this.effectMid) / (1 - this.effectMid);
            elevation = (Math.cos(radio * Math.PI) - (-1)) / 2;
          }

          vec.setValue(this.elevationAxis, val + elevation * this.elevationHeight * this.intensity);
        }
      }
    }

    // ============================================
    // FlipPage class
    // ============================================
    const flipXUV = (geo) => {
      const uvAttribute = geo.attributes.uv;
      for (let i = 0; i < uvAttribute.count; i++) {
        const u = uvAttribute.getX(i);
        const v = uvAttribute.getY(i);
        uvAttribute.setXY(i, 1 - u, v);
      }
      return geo;
    };

    const NOTEXTURE = new THREE.MeshStandardMaterial({ color: "#ffffff" });

    class FlipPage extends THREE.Mesh {
      constructor(subdivisions = 10) {
        super();

        const plane = new THREE.Mesh(
          mergeGeometries(
            [
              flipXUV(new THREE.PlaneGeometry(1, 1, subdivisions, subdivisions)),
              flipXUV(new THREE.PlaneGeometry(1, 1, subdivisions, subdivisions).rotateY(Math.PI))
            ],
            true
          ),
          [NOTEXTURE, NOTEXTURE]
        );

        plane.castShadow = true;
        plane.receiveShadow = true;
        plane.rotateX(Math.PI / 2);
        plane.position.x = 0.5;
        this.scale.z = -1;
        this.add(plane);
        this.page = plane;

        this.modifiers = new MODIFIERS.ModifierStack(plane);

        this.bend = new MODIFIERS.Bend(0, 0, 0);
        this.bend.constraint = MODIFIERS.ModConstant.LEFT;

        this.twist = new MODIFIERS.Twist(0);
        this.twist.vector = new MODIFIERS.Vector3(2, 0, 0);
        this.twist.center = new MODIFIERS.Vector3(-0.5, 0, 0);

        this.pageCurve = new PageCurve(
          MODIFIERS.ModConstant.Z,
          MODIFIERS.ModConstant.X,
          0.812,
          0.325,
          0.054
        );

        this.modifiers.addModifier(this.pageCurve);
        this.modifiers.addModifier(this.bend);
        this.modifiers.addModifier(this.twist);
      }

      setPageMaterial(newMaterial, index) {
        this.page.material[index] = newMaterial;
      }

      flip(progress, direction, pageCurveIntensity = 1) {
        this.rotation.z = Math.PI * progress;
        this.bend.force = Math.min(-Math.sin(this.rotation.z) / 2, -0.0001) * direction;
        this.twist.angle = Math.sin(this.rotation.z) / 10;
        this.pageCurve.intensity = (-1 + 2 * progress) * (-Math.sin(this.rotation.z) + 1) * pageCurveIntensity;
        this.modifiers.apply();
      }

      reset() {
        this.setPageMaterial(NOTEXTURE, 0);
        this.setPageMaterial(NOTEXTURE, 1);
      }

      dispose(materialToo = false) {
        if (materialToo) {
          if (this.page.material[0] !== NOTEXTURE) this.page.material[0].dispose();
          if (this.page.material[1] !== NOTEXTURE) this.page.material[1].dispose();
        }
        this.page.geometry.dispose();
        this.modifiers.destroy();
      }
    }

    // ============================================
    // FlipBook class
    // ============================================
    const AOTexture = (() => {
      let texture;
      return () => {
        if (!texture) {
          const canvas = document.createElement('canvas');
          canvas.width = 256;
          canvas.height = 256;
          const ctx = canvas.getContext('2d');
          const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          gradient.addColorStop(0, 'black');
          gradient.addColorStop(0.1, 'white');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          texture = new THREE.CanvasTexture(canvas);
          canvas.remove();
        }
        return texture;
      };
    })();

    class FlipBook extends THREE.Mesh {
      constructor(config) {
        super();
        this.pages = [];
        this.pool = [];
        this._url2Loader = new Map();
        this._currentProgress = 0;
        this._flipDuration = config?.flipDuration || 1;
        this._ySpacing = config?.yBetweenPages || 0.001;
        this._pageSubdivisions = config?.pageSubdivisions || 20;
        this._stepSize = 0;
        this._flipDirection = 1;
        this._goalProgress = 0;
        this._currentPage = 0;
        this.currentPage = 0;
      }

      [Symbol.iterator]() {
        let index = 0;
        return {
          next: () => index < this.pages.length 
            ? { value: this.pages[index++], done: false } 
            : { value: null, done: true }
        };
      }

      setPages(pagesSources) {
        if (pagesSources.length % 2 !== 0) {
          pagesSources.push("");
        }

        while (this.pages.length) {
          const page = this.pages.pop();
          page.reset();
          this.pool.push(page);
          this.remove(page);
        }

        let prom = Promise.resolve();

        for (let i = 0; i < pagesSources.length; i += 2) {
          const urlA = pagesSources[i];
          const urlB = pagesSources[i + 1];
          let page = this.pool.pop();

          if (!page) {
            page = new FlipPage(this._pageSubdivisions);
          }

          this.add(page);
          page.position.y = -this._ySpacing * this.pages.length;
          this.pages.push(page);
          page.name = `Page#${this.pages.length}`;

          prom = prom.then(this.loadPages(urlA, urlB, page));
        }

        if (this.currentPage > this.pages.length * 2 - 1) {
          this._currentPage = this.pages.length * 2 - 1;
          this._currentProgress = this.pages.length;
        }

        this.flipPages();
      }

      get totalPages() {
        return this.pages.length * 2;
      }

      loadPages(sourceA, sourceB, page) {
        return () => Promise.all([
          this.loadPage(sourceA, 1, page),
          this.loadPage(sourceB, 0, page)
        ]);
      }

      loadPage(source, side, page) {
        if (!source || source === '') {
          const blankPage = new THREE.MeshStandardMaterial({
            color: "white",
            roughness: 0.2,
            aoMapIntensity: 0.7,
            aoMap: side == 1 ? AOTexture() : null
          });
          page.setPageMaterial(blankPage, side);
          return Promise.resolve();
        }

        if (source instanceof THREE.Material) {
          page.setPageMaterial(source, side);
          return Promise.resolve();
        }

        if (source instanceof THREE.Texture) {
          page.setPageMaterial(this.textureToMaterial(source, side), side);
          return Promise.resolve();
        }

        const url = source;

        if (!this._url2Loader.has(url)) {
          this._url2Loader.set(url, new Promise((resolve, reject) => {
            new THREE.TextureLoader().load(
              source,
              (texture) => resolve(this.textureToMaterial(texture, side)),
              undefined,
              (err) => resolve(null)
            );
          }));
        }

        return this._url2Loader.get(url).then((material) => {
          page.setPageMaterial(material, side);
        });
      }

      textureToMaterial(texture, side) {
        texture.magFilter = THREE.LinearFilter;
        texture.minFilter = THREE.LinearFilter;
        texture.generateMipmaps = false;
        texture.colorSpace = THREE.SRGBColorSpace;

        return new THREE.MeshStandardMaterial({
          color: "white",
          map: texture,
          roughness: 0.2,
          aoMapIntensity: 0.7,
          aoMap: side == 1 ? AOTexture() : null,
          toneMapped: false
        });
      }

      get currentPage() {
        return this._currentPage;
      }

      set currentPage(n) {
        let goal = Math.ceil(n / 2);
        let distance = goal - this._currentProgress;
        this._stepSize = distance / this._flipDuration;
        this._flipDirection = this._stepSize > 0 ? 1 : -1;
        this._currentPage = Math.ceil(n);
        this._goalProgress = goal;
        this.flipPages();
      }

      get progress() {
        return this._currentProgress;
      }

      set progress(p) {
        let oldProgress = this._currentProgress;
        this._currentProgress = Math.max(0, Math.min(p, this.pages.length));
        this._currentPage = Math.floor(this._currentProgress * 2);
        this._stepSize = 0;
        this._flipDirection = this._currentProgress > oldProgress ? 1 : -1;
        this.flipPages();
      }

      animate(delta) {
        if (this._stepSize != 0) {
          this._currentProgress += this._stepSize * delta;

          if ((this._stepSize > 0 && this._currentProgress > this._goalProgress) ||
              (this._stepSize < 0 && this._currentProgress < this._goalProgress)) {
            this._currentProgress = this._goalProgress;
            this._stepSize = 0;
          }

          this.flipPages();
        }
      }

      flipPage(page) {
        const pageIndex = this.pages.indexOf(page);
        if (pageIndex < 0) throw new ReferenceError("I don't own that page!");

        const A = pageIndex * 2;
        const B = A + 1;
        this.currentPage = this._currentPage <= A ? B : A;
      }

      nextPage() {
        this.currentPage = Math.min(Math.ceil(this.currentPage / 2) + 1, this.pages.length) * 2;
      }

      previousPage() {
        this.currentPage = Math.max(Math.ceil(this.currentPage / 2) - 1, 0) * 2;
      }

      flipPages() {
        const totalPages = this.pages.length;
        let activeProgress = this._currentProgress % 1;
        let activeIndex = Math.floor(this._currentProgress);

        for (let i = 0; i < totalPages; i++) {
          const page = this.pages[i];
          const pageProgress = activeIndex < i ? 0 : activeIndex > i ? 1 : activeProgress;
          const yProgress = pageProgress < 0.5 ? 0 : (pageProgress - 0.5) / 0.5;
          const leftPileY = -this._ySpacing * (totalPages - i);
          const rightPileY = -this._ySpacing * i;
          const pageCurveEffectIntensity = this._currentProgress < 1 ? activeProgress :
            this._currentProgress >= totalPages ? 0 :
            this._currentProgress >= totalPages - 1 ? 1 - activeProgress : 1;

          page.flip(pageProgress, this._flipDirection, pageCurveEffectIntensity);
          page.position.y = rightPileY + yProgress * (leftPileY - rightPileY);
        }

        const offset = activeIndex == 0 ? -0.5 + 0.5 * activeProgress :
          activeIndex == totalPages - 1 ? 0.5 * activeProgress :
          activeIndex == totalPages ? 0.5 : 0;

        this.position.x = offset * this.scale.x;
      }

      dispose() {
        while (this.pages.length) {
          const page = this.pages.pop();
          this.remove(page);
        }
        while (this.pool.length) {
          this.pool.pop().dispose(true);
        }
        this._url2Loader.forEach(m => m.then(mat => mat?.dispose()));
        this._url2Loader.clear();
      }
    }

    // ============================================
    // Scene Setup (matching demo's main.js)
    // ============================================
    const container = document.getElementById('book-container');
    const width = container.clientWidth;
    const height = container.clientHeight;

    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    // Lighting (matching demo)
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(0.2, 1, 0);
    light.castShadow = true;
    light.shadow.mapSize.width = 512 * 4;
    light.shadow.mapSize.height = 512 * 4;
    light.shadow.camera.near = 0.5;
    light.shadow.camera.far = 3;
    light.shadow.bias = -0.003;
    scene.add(light);

    const ambientLight = new THREE.AmbientLight(0xffffff, 2);
    scene.add(ambientLight);

    // Camera (zoomed out for smaller book)
    const MAXFOV = 32;
    const camera = new THREE.PerspectiveCamera(0, width / height, 0.1, 1000);
    camera.setFocalLength(MAXFOV);
    camera.position.set(0, 4, 1.2);
    camera.lookAt(0, 0, 0);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setSize(width, height);
    renderer.toneMapping = THREE.NoToneMapping;
    container.appendChild(renderer.domElement);

    // FlipBook
    const book = new FlipBook({
      flipDuration: 0.5,
      yBetweenPages: 0.001,
      pageSubdivisions: 20
    });

    book.scale.x = 0.8;
    book.position.x = 0; // Centered
    scene.add(book);

    book.setPages(pageImages);

    // Clock for animation
    const clock = new THREE.Clock();

    // ============================================
    // Page Flip Sound
    // ============================================
    const flipSound = new Audio('vendor/3dflipbook/sounds/start-flip.mp3');
    flipSound.volume = 0.4;
    
    function playFlipSound() {
      flipSound.currentTime = 0;
      flipSound.play().catch(() => {}); // Catch autoplay restrictions
    }

    // Levitation animation
    let levitationTime = 0;
    const LEVITATION_HEIGHT = 0.04;
    const LEVITATION_TILT = 0.015;
    
    // Random seeds for organic movement
    const randomSeed1 = Math.random() * 100;
    const randomSeed2 = Math.random() * 100;
    const randomSeed3 = Math.random() * 100;

    // ============================================
    // Interactive Rotation Controls
    // ============================================
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let dragStartTime = 0;
    let totalDragDistance = 0;
    
    // User-controlled rotation (persists)
    let userRotationX = 0.3; // Start with slight tilt down to see book better
    let userRotationY = 0;
    
    // Velocity for inertia
    let velocityX = 0;
    let velocityY = 0;
    
    // Previous positions for velocity calculation
    let prevDragX = 0;
    let prevDragY = 0;
    
    const DRAG_SENSITIVITY = 0.008;
    const INERTIA_FRICTION = 0.95;
    const INERTIA_THRESHOLD = 0.0001;
    const CLICK_THRESHOLD = isMobile() ? 30 : 15; // pixels - max movement for a click (more forgiving on mobile)
    const CLICK_TIME_THRESHOLD = 400; // ms - max time for a click
    
    // Rotation limits
    const MAX_ROTATION_X = Math.PI / 2.5; // How much you can tilt up/down
    const MIN_ROTATION_X = -0.2;

    // ============================================
    // Responsive Camera Adjustment
    // ============================================
    function isMobile() {
      return window.innerWidth <= 768;
    }
    
    function adjustCameraForDevice() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      
      // Minimum focal length to prevent book from getting too small
      // Higher value = more zoomed in = larger book
      const MIN_FOCAL_LENGTH = 44;
      
      if (isMobile()) {
        // Mobile: zoom in for larger book
        camera.setFocalLength(55);
        camera.position.set(0, 2.4, 0.75);
      } else {
        // Desktop - responsive scaling based on window size
        // Use the smaller dimension to ensure book fits well
        const minDimension = Math.min(width, height);
        
        // Zoom in more for smaller windows, keep original for large windows
        if (minDimension < 500) {
          // Very small windows - zoom in significantly
          camera.setFocalLength(52);
          camera.position.set(0, 2.6, 0.8);
        } else if (minDimension < 600) {
          // Small windows - zoom in more
          camera.setFocalLength(46);
          camera.position.set(0, 2.9, 0.9);
        } else if (minDimension < 700) {
          // Medium-small windows
          camera.setFocalLength(42);
          camera.position.set(0, 3.2, 1.0);
        } else {
          // Medium and large windows - use minimum focal length
          // This prevents the book from shrinking too small
          camera.setFocalLength(Math.max(MAXFOV, MIN_FOCAL_LENGTH));
          camera.position.set(0, 3.6, 1.1);
        }
      }
      camera.lookAt(0, 0, 0);
      camera.updateProjectionMatrix();
    }

    // ============================================
    // Event Handlers
    // ============================================
    function onWindowResize() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      adjustCameraForDevice();
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }

    function tryFlipPage(clientX, clientY) {
      const rect = renderer.domElement.getBoundingClientRect();
      const mouse = new THREE.Vector2();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);

      if (intersects.length) {
        // Find the FlipPage parent
        let obj = intersects[0].object;
        while (obj && !(obj instanceof FlipPage)) {
          obj = obj.parent;
        }
        if (obj && obj instanceof FlipPage) {
          book.flipPage(obj);
          playFlipSound();
          updatePageIndicator();
          return true;
        }
      }
      
      // Mobile fallback: if raycast missed but tap was on book area, flip based on screen position
      if (isMobile() && book.pages.length > 0) {
        // Calculate normalized X position within canvas
        const normalizedX = (clientX - rect.left) / rect.width;
        
        // Flip forward if tapped on right side, backward if left side
        if (normalizedX > 0.5 && book.currentPage < book.totalPages) {
          book.nextPage();
          playFlipSound();
          updatePageIndicator();
          return true;
        } else if (normalizedX <= 0.5 && book.currentPage > 0) {
          book.previousPage();
          playFlipSound();
          updatePageIndicator();
          return true;
        }
      }
      
      return false;
    }

    // ============================================
    // Mouse Drag Controls
    // ============================================
    function onMouseDown(event) {
      isDragging = true;
      dragStartX = event.clientX;
      dragStartY = event.clientY;
      prevDragX = event.clientX;
      prevDragY = event.clientY;
      dragStartTime = Date.now();
      totalDragDistance = 0;
      velocityX = 0;
      velocityY = 0;
      renderer.domElement.style.cursor = 'grabbing';
    }

    function onMouseMove(event) {
      if (!isDragging) return;
      
      const deltaX = event.clientX - prevDragX;
      const deltaY = event.clientY - prevDragY;
      
      // Update total drag distance for click detection
      totalDragDistance += Math.abs(deltaX) + Math.abs(deltaY);
      
      // Update rotation based on drag
      userRotationY += deltaX * DRAG_SENSITIVITY;
      userRotationX += deltaY * DRAG_SENSITIVITY;
      
      // Clamp X rotation
      userRotationX = Math.max(MIN_ROTATION_X, Math.min(MAX_ROTATION_X, userRotationX));
      
      // Calculate velocity for inertia
      velocityX = deltaY * DRAG_SENSITIVITY;
      velocityY = deltaX * DRAG_SENSITIVITY;
      
      prevDragX = event.clientX;
      prevDragY = event.clientY;
    }

    function onMouseUp(event) {
      if (!isDragging) return;
      isDragging = false;
      renderer.domElement.style.cursor = 'grab';
      // Page flipping is now handled by the click event listener
    }

    // ============================================
    // Touch Controls for Mobile
    // ============================================
    function onTouchStart(event) {
      if (event.touches.length === 1) {
        // Prevent default touch behavior on the canvas for better control
        event.preventDefault();
        
        const touch = event.touches[0];
        isDragging = true;
        dragStartX = touch.clientX;
        dragStartY = touch.clientY;
        prevDragX = touch.clientX;
        prevDragY = touch.clientY;
        dragStartTime = Date.now();
        totalDragDistance = 0;
        velocityX = 0;
        velocityY = 0;
      }
    }

    function onTouchMove(event) {
      if (!isDragging || event.touches.length !== 1) return;
      
      event.preventDefault(); // Prevent scrolling while rotating
      
      const touch = event.touches[0];
      const deltaX = touch.clientX - prevDragX;
      const deltaY = touch.clientY - prevDragY;
      
      // Update total drag distance for click detection
      totalDragDistance += Math.abs(deltaX) + Math.abs(deltaY);
      
      // Update rotation based on drag
      userRotationY += deltaX * DRAG_SENSITIVITY;
      userRotationX += deltaY * DRAG_SENSITIVITY;
      
      // Clamp X rotation
      userRotationX = Math.max(MIN_ROTATION_X, Math.min(MAX_ROTATION_X, userRotationX));
      
      // Calculate velocity for inertia
      velocityX = deltaY * DRAG_SENSITIVITY;
      velocityY = deltaX * DRAG_SENSITIVITY;
      
      prevDragX = touch.clientX;
      prevDragY = touch.clientY;
    }

    function onTouchEnd(event) {
      if (!isDragging) return;
      
      const dragDuration = Date.now() - dragStartTime;
      const wasClick = totalDragDistance < CLICK_THRESHOLD && dragDuration < CLICK_TIME_THRESHOLD;
      
      isDragging = false;
      
      // If it was a tap (not a drag), try to flip page using the ORIGINAL touch position
      if (wasClick) {
        // Prevent default to ensure our tap handler works on iOS
        event.preventDefault();
        event.stopPropagation();
        
        // Small delay to ensure raycasting works after touch release on iOS Safari
        requestAnimationFrame(() => {
          tryFlipPage(dragStartX, dragStartY);
        });
      }
    }

    function updatePageIndicator() {
      const currentPageNum = book.currentPage + 1;
      document.getElementById('current-page').textContent = Math.min(currentPageNum, book.totalPages);
      document.getElementById('total-pages').textContent = book.totalPages;

      document.getElementById('btn-prev').disabled = book.currentPage === 0;
      document.getElementById('btn-next').disabled = book.currentPage >= book.totalPages;
    }

    // ============================================
    // Button Controls
    // ============================================
    document.getElementById('btn-prev').addEventListener('click', () => {
      if (book.currentPage > 0) {
        book.previousPage();
        playFlipSound();
        updatePageIndicator();
      }
    });

    document.getElementById('btn-next').addEventListener('click', () => {
      if (book.currentPage < book.totalPages) {
        book.nextPage();
        playFlipSound();
        updatePageIndicator();
      }
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight' || e.key === ' ') {
        if (book.currentPage < book.totalPages) {
          book.nextPage();
          playFlipSound();
          updatePageIndicator();
        }
      } else if (e.key === 'ArrowLeft') {
        if (book.currentPage > 0) {
          book.previousPage();
          playFlipSound();
          updatePageIndicator();
        }
      }
    });

    // ============================================
    // Event Listeners
    // ============================================
    window.addEventListener('resize', onWindowResize);
    
    // Track if last interaction was a drag (to prevent click from firing after drag)
    let wasDragged = false;
    
    // Mouse events for rotation
    renderer.domElement.addEventListener('mousedown', (event) => {
      onMouseDown(event);
      wasDragged = false;
    });
    window.addEventListener('mousemove', (event) => {
      if (isDragging && totalDragDistance > CLICK_THRESHOLD) {
        wasDragged = true;
      }
      onMouseMove(event);
    });
    window.addEventListener('mouseup', onMouseUp);
    
    // Click handler for page flipping
    renderer.domElement.addEventListener('click', (event) => {
      // Only flip page if it wasn't a drag
      if (!wasDragged) {
        tryFlipPage(event.clientX, event.clientY);
      }
      wasDragged = false;
    });
    
    // Touch events - all non-passive to ensure proper handling on iOS Safari
    renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
    renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
    renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
    renderer.domElement.addEventListener('touchcancel', onTouchEnd, { passive: false });
    
    // Set initial cursor
    renderer.domElement.style.cursor = 'grab';

    // ============================================
    // Animation Loop
    // ============================================
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      book.animate(delta);
      
      // Update time
      levitationTime += delta;
      
      // Apply inertia when not dragging
      if (!isDragging) {
        if (Math.abs(velocityX) > INERTIA_THRESHOLD || Math.abs(velocityY) > INERTIA_THRESHOLD) {
          userRotationX += velocityX;
          userRotationY += velocityY;
          
          // Clamp X rotation
          userRotationX = Math.max(MIN_ROTATION_X, Math.min(MAX_ROTATION_X, userRotationX));
          
          // Apply friction
          velocityX *= INERTIA_FRICTION;
          velocityY *= INERTIA_FRICTION;
        }
      }
      
      // Subtle organic levitation (reduced when user is interacting)
      const interactionDamping = isDragging ? 0.3 : 1;
      const floatY = 
        Math.sin(levitationTime * 1.2 + randomSeed1) * LEVITATION_HEIGHT * 0.6 * interactionDamping +
        Math.sin(levitationTime * 0.7 + randomSeed2) * LEVITATION_HEIGHT * 0.3 * interactionDamping +
        Math.sin(levitationTime * 2.1 + randomSeed3) * LEVITATION_HEIGHT * 0.1 * interactionDamping;
      
      // Very subtle organic tilt variations (reduced for user control)
      const baseTiltZ = Math.cos(levitationTime * 0.6 + randomSeed2) * LEVITATION_TILT * 0.5 * interactionDamping;
      
      // Apply combined rotations: user rotation + subtle levitation
      book.position.y = floatY;
      book.rotation.x = userRotationX;
      book.rotation.y = userRotationY;
      book.rotation.z = baseTiltZ;
      
      renderer.render(scene, camera);
    }

    // ============================================
    // Initialize
    // ============================================
    adjustCameraForDevice();
    updatePageIndicator();

    // Hide loading overlay
    setTimeout(() => {
      document.getElementById('loading').classList.add('hidden');
      
      const overlay = document.querySelector('.page-transition-overlay');
      if (overlay) {
        overlay.classList.add('hidden');
        overlay.addEventListener('transitionend', () => overlay.remove(), { once: true });
      }
    }, 500);

    animate();
  </script>
</body>
</html>

